(load "package-and-global-variable.lisp")


(defmacro set-last (list value)
  `(if (null ,list)
       (setf ,list (cons ,value ,list))
       (progn (setf (cdr (last ,list)) ,value) ,list)))


(defun anve-change-body (args new-args body)
  (if (null args)
      body
      (anve-change-body (cdr args) (cdr new-args)
			(let ((a (car args)) (b (car new-args)))
			  (mapcar #'(lambda (x)
				      (cond ((consp x)
					     (anve-change-body args new-args x))
					    ((eql a x) b)
					    (t x)))
				  body)))))

(defun make-initial-args (list)
  (mapcar (let ((x 0))
	    #'(lambda (y) y ;just for no warning
		      (incf x)
		      (make-package-name (format nil "ARG-~A" x))))
	  list))

;;; may have some futility code, could i search some time to delete it
(defmacro anve-defun (name action &body lambda-list)
  (let ((body-list (gensym))
	(args-list (gensym))
	(action-nm (gensym))
	(func-name (make-package-name name)))
    `(progn
       (setf (gethash (make-package-name',func-name)
		      *anve-function-list-save-place*)
	     (let ((,body-list nil)
		   (,args-list ',lambda-list)
		   (,action-nm (if (listp ',action) ',action (list ',action))))
	       #'(lambda (&optional (how-do? 'get-body) value)
		   (declare (type list ,body-list ,args-list value ,action-nm)
			    (type symbol how-do?))
		   ;;i don't know what place use other package,
		   ;;but if you wanna this function can use in other
		   ;;package, change "eq" to "string-equal"
		   (cond ((eq how-do? 'get-body) ,body-list)
			 ((eq how-do? 'get-args) ,args-list)
			 ((eq how-do? 'get-action) ,action-nm)
			 ((and value (not (listp value)))
			  (error "The ~A is not of type LIST" value))
			 ((and (eq how-do? 'set-body-car) value)
			  (setf (car ,body-list) value))
			 ((and (eq how-do? 'set-body-cdr) value)
			  (setf (cdr ,body-list) value))
			 ((and (eq how-do? 'append-body) value)
			  (setq ,body-list (nconc value ,body-list)))
			 ((and (eq how-do? 'push-body)value)
			  (push value ,body-list))
			 ((eq how-do? 'pop-body) (pop ,body-list))
			 ((and (eq how-do? 'set-body) value)
			  (setq ,body-list value))
			 ((and (eq how-do? 'set-body-last) value)
			  (set-last ,body-list (list value)))
			 ((or (string-equal how-do? 'set-body)
			      (eq how-do? 'set-body-car)
			      (eq how-do? 'set-body-cdr)
			      (eq how-do? 'append-body)
			      (eq how-do? 'push-body))
			  (error "You musi input a VALUE in ~A" ',func-name))
			 (t (error "Unknown type in ~A: ~A" ',func-name how-do?))))))
       (defun ,name ,lambda-list (list ,@lambda-list)))))

(defun append-last (list-1 list-2)
  (cond ((null list-1) nil)
	((and (listp (car list-1)) (null (cdr list-1)))
	 (list (append-last (car list-1) list-2)))
	((null (cdr list-1))
	 (append list-1 list-2))
	(t (cons (car list-1)
		 (append-last (cdr list-1) list-2)))))

(defun anve-print-now-function-body (name &optional (direction #'append-last))
  (let* ((name-of-package (make-package-name name))
	 (function (gethash name-of-package *anve-function-list-save-place*))
	 (lambda-list (funcall function 'get-args))
	 (body-arg-list (make-initial-args lambda-list)))
    `#'(lambda ,lambda-list
	 ,(anve-change-body body-arg-list lambda-list
			    (funcall direction (funcall function 'get-action)
				     (funcall function))))))

(defmacro anve-update-function (name &optional (direction #'append-last))
  `(progn (setf (symbol-function ',name)
		,(anve-print-now-function-body name direction))
	  ',name))

;(defun append-last (list-1 list-2)
 ; (labels ((iter (lst1 lst2 lst3)
;	     (format t "lst1 is: ~A; lst2 is: ~A; lst3 is:~A~%" lst1 lst2 lst3)
;	     (read)
;	     (if (null (cdr lst1))
;		 (append (nreverse lst3) lst1 lst2)
;		 (iter (cdr lst1) lst2 (cons (car lst1) lst3)))))
 ;   (iter list-1 list-2 nil)))

;(defun append-last (list-1 list-2)
 ; (labels ((iter (lst1 lst2 lst3)
;	     (cond ((and (listp (car lst1)) (null (cdr lst1)))
;		    (list (iter (iter (car lst1) lst2 nil))) nil lst3))
;		   ((null (cdr lst1))
;		    (append (nreverse lst3) lst1 lst2))
;		   (t (iter (cdr lst1) lst2 (cons (car lst1) lst3))))))
 ;   (iter list-1 list-2 nil)))

(defmacro anve-defbody (name lambda-list place &body body)
  (let ((func-name (make-package-name name))
	(true-body `(anve-change-body ',lambda-list
				      (make-initial-args ',lambda-list)
				      ',body)))
    `(cond ((not (= (length ',lambda-list)
		    (length (funcall (gethash',func-name
				      *anve-function-list-save-place*)
				     'get-args))))
	    (error "Error in lambda-list"))
	   ((eq ,place 'first)
	    (funcall (gethash ',func-name *anve-function-list-save-place*)
		     'push-body ,true-body))
	   ((eq ,place 'last)
	    (funcall (gethash ',func-name *anve-function-list-save-place*)
		     'set-body-last ,true-body))
	   ((eq ,place 'append)
	    (funcall (gethash ',func-name *anve-function-list-save-place*)
		     'append-body ,true-body))
	   (t (error "Unknown place in ~A" ',name)))))

